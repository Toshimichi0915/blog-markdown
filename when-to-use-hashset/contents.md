# HashSetの使い所

大量の要素を保存する必要がある場合、ArrayListだと性能劣化が激しく使い物にならないケースがある。原因はArrayListの内部実装にあり、ArrayListは要素が一杯になると内部の配列のサイズを拡張するため、大量のオブジェクトが保管されていると大容量の配列をコピーする必要があり、性能が激しく劣化する。

またオブジェクトの追加以外でも、例えば検索（indexOf、contains）のパフォーマンスは要素数が増えると劇的に遅くなる。これは追加と検索を繰り返して行うようなプログラムでは致命的になる。

```java
    private void add(E e, Object[] elementData, int s) {
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1;
    }
```
ArrayListの内部実装から抜粋

そのため大容量のデータを保存する必要があり、かつ要素の数が事前にわからない場合はHashSetを利用する手段が考えられる。

## HashSetとは

HashSetは内部的にオブジェクトのハッシュ値とオブジェクトを関連付けて保存する。ハッシュ値というのはオブジェクトのフィールドの値から求められる値であり、通常hashCodeによって計算される（hashCodeメソッドを実装していない場合はJVMがオブジェクトのポインタの値から計算することが多い）。なぜhashCode?と思うかもしれないが、それには深い理由が存在する。

通常ArrayListで検索を行うとき、最初の要素から最後の要素までforループで回していって、Object#equalsでオブジェクトが同一かチェックする。だがこれには問題点があり、

1. フィールドが複数ある場合equalsメソッドは遅い
2. 最悪のケースで要素の最初から最後までforループを回さなければならず、要素が増えると検索にかかる時間が増えていく。

といった課題がある。だがhashCodeを使ってオブジェクトに固有な整数を生成することで、これらの問題を解決することができる。

1. 最初にhashCodeを使って検索して、同じhashCodeを持つオブジェクトに対してのみequalsを試せばいい（同じhashCodeを持つオブジェクトが偶然できるかもしれないので、hashCodeが同じでもequalsによる検証は必要である）
2. hashCodeを**辞書のページ**のように扱うことで、定数時間での計算が可能になる。

2が非常に大きく、これによりHashSetでの検索がO(1)で行える。オブジェクトを追加する際はhashCodeの値に基づいて（HashMapの）内部の配列に追加するが、HashSetはindexOfをサポートしないので配列に一つずつ要素を格納する必要はなく、例えばHashSetが作成されたときに内部的にサイズが16の配列を作成して、要素が追加されたときは内部配列のhashCode % 16番目の要素にLinkedListとして追加すれば良い。

## HashSetの問題点

今述べたようにHashSetには定数時間で検索・追加ができるという大きな利点があるのだが、問題点も複数存在する。それは

・indexOfが使用できない
・ハッシュ衝突攻撃に対して脆弱である（だがこれはJava特有の問題で、例えばRustではデフォルト実装がハッシュ衝突攻撃に耐性を持っている）

という問題点がある。indexOfが利用できないというのは当たり前かもしれないが、ハッシュ衝突攻撃とはなんだろうか。

### ハッシュ衝突攻撃とは

ハッシュ衝突攻撃とは、攻撃者が同じhashCodeを返す複数のオブジェクトを大量に生成して送りつけることで、性能を悪化させる攻撃である。またHashSetはハッシュが大量に衝突すると自動でハッシュテーブル（ハッシュ値とオブジェクトを関連付けるテーブル）を拡大するため、ArrayListと同様に配列のコピーによる性能劣化が発生する。
